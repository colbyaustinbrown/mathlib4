/-
Copyright (c) 2025 Colby Brown. All rights reserved.
Released under pache 2.0 license as described in the file LICENSE.
Author: Colby Brown
-/
import Mathlib.CategoryTheory.Topos.Classifier
import Mathlib.CategoryTheory.Monoidal.Cartesian.Basic
import Mathlib.CategoryTheory.Closed.Cartesian

/-!

## Main definitions
-/

universe u v

namespace CategoryTheory

open CategoryTheory Category Limits HasClassifier
open MonoidalCategory CartesianMonoidalCategory

noncomputable section

section
variable (Œµ : Type u) [Category.{v} Œµ] [HasPullbacks Œµ] [HasClassifier Œµ]

/-- Categories with pullbacks, a terminal object, and a classifier.
We make this a separate class to help put a `CartesianMonoidalCategory` instance
on topoi with nice definitional equality properties between the terminal objects
given by the `HasPullbacks` and `HasClassifier` instances, and also the monoidal unit. -/
class HasPullbacksTerminalClassifier (Œµ: Type u) [Category.{v} Œµ] [HasPullbacks Œµ] [HasClassifier Œµ]

/-- Every category with pullbacks, a terminal object, and a classifier is cartesian monoidal. -/
instance : CartesianMonoidalCategory Œµ :=
  have := (HasClassifier.isTerminalŒ©‚ÇÄ Œµ).hasTerminal
  have := hasBinaryProducts_of_hasTerminal_and_pullbacks Œµ
  .ofChosenFiniteProducts
    (ùíØ := {
      cone := { pt := HasClassifier.Œ©‚ÇÄ Œµ, œÄ := { app X := X.as.elim } }
      isLimit := .mkConeMorphism
        (lift := fun _ ‚Ü¶ { hom := HasClassifier.œá‚ÇÄ _ })
        (uniq := fun _ _ ‚Ü¶ by ext; apply (HasClassifier.isTerminalŒ©‚ÇÄ Œµ).hom_ext)
    })
    (‚Ñ¨ := fun _ _ ‚Ü¶ Limits.getLimitCone _)

/-- A topos `Œµ` is a category with pullbacks, a terminal object, and a classifier, along with an
object map `P` and, to each arrow `f: B √ó A ‚ü∂ Œ©`, an arrow `‚àà B: B √ó BP ‚ü∂ Œ©`, such that there is
a unique arrow `g: A ‚ü∂ PB` making the following diagram commute.
```
    B √ó A --------f---------> Œ© 
      |                         
    1 √ó g                    | |
      |                      | |
      v                       
    B √ó PB ------‚àà B--------> Œ©
```
-/
class Topos extends HasPullbacksTerminalClassifier Œµ where
  /-- The object map `P`. Later, we will show that this map gives a contravariant
  endofunctor `P`. -/
  P' (B : Œµ) : Œµ
  /-- The membership arrow. -/
  mem (B: Œµ): (B ‚äó P' B) ‚ü∂ HasClassifier.Œ© Œµ
  /-- The membership arrow induces a unique arrow making the diagram commute. -/
  exists_transpose {A B: Œµ} (f: B ‚äó A ‚ü∂ Œ© Œµ):
    ‚àÉ! (g: A ‚ü∂ P' B), (B ‚óÅ g) ‚â´ mem B = f

end
variable {Œµ : Type u} [Category.{v} Œµ] [HasPullbacks Œµ] [HasClassifier Œµ] [Topos Œµ] {A : Œµ}

namespace Topos

section
variable {B C : Œµ}

/-- The transpose of an arrow `f: B ‚äó A ‚ü∂ Œ©` is the unique arrow `g: A ‚ü∂ P' B` making the following
diagram commute:
```
    B √ó A --------f---------> Œ© 
      |                         
    1 √ó g                    | |
      |                      | |
      v                       
    B √ó PB ------‚àà B--------> Œ©
```
Furthermore, each `g: A ‚ü∂ P' B` is the transpose of a unique `f: B ‚äó A ‚ü∂ Œ©`.
-/
def transpose {A B : Œµ} : (B ‚äó A ‚ü∂ Œ© Œµ) ‚âÉ (A ‚ü∂ P' B) where
  toFun f := (exists_transpose f).choose
  invFun g := B ‚óÅ g ‚â´ mem B
  left_inv f := (exists_transpose f).choose_spec.left
  right_inv g := by
    have := (exists_transpose (B ‚óÅ g ‚â´ mem B)).choose_spec.right g
    simp at this
    exact this.symm

@[reassoc (attr := simp)]
theorem whiskerLeft_transpose_comp_mem {f : B ‚äó A ‚ü∂ Œ© Œµ} :
    B ‚óÅ transpose f ‚â´ mem B = f := by
  simp [transpose, (exists_transpose f).choose_spec.left]

@[simp]
theorem transpose_whiskerLeft_comp_eq_comp_transpose (f : A ‚ü∂ P' (C ‚äó B))
    (g : B ‚äó P' (C ‚äó B) ‚ü∂ Œ© Œµ) : transpose (B ‚óÅ f ‚â´ g) = f ‚â´ transpose g := by
  dsimp [transpose]
  apply (exists_transpose _).unique
  ¬∑ erw [whiskerLeft_transpose_comp_mem]
  ¬∑ simp [(exists_transpose _).choose_spec.left]

/-- The diagonal map, whose composition with either projection is `ùüô B`. -/
abbrev diag (B : Œµ) : B ‚ü∂ B ‚äó B := lift (ùüô B) (ùüô B)

/-- The equaility predicate, as in the diagram
```
      B   ------------------> ‚ä§ 
      |                       | 
    diag B                    | true 
      |                       | 
      v                       v
    B √ó B --equality_pred---> Œ©.
```
Also called the "Kronecker delta". -/
def equality_pred (B : Œµ) : B ‚äó B ‚ü∂ Œ© Œµ :=
  HasClassifier.œá (lift (ùüô B) (ùüô B))

scoped notation "Œ¥" => equality_pred

abbrev singleton (B : Œµ) := transpose (Œ¥ B)

/-- The singleton arrow is monic. ([MM92], Lemma IV.2.1) -/
@[instance]
lemma singleton.Mono (B : Œµ) : Mono (singleton B) where
  right_cancellation {Z} b‚ÇÅ b‚ÇÇ h := by
    replace h: B ‚óÅ b‚ÇÅ ‚â´ Œ¥ B = (B ‚óÅ b‚ÇÇ) ‚â´ Œ¥ B := by
      apply transpose.symm.apply_eq_iff_eq.mpr at h
      simp [transpose] at h
      exact h
    let pb (b : Z ‚ü∂ B) := PullbackCone.mk (f := diag B) (g := B ‚óÅ b)
      (fst := b) (snd := lift b (ùüô Z))
      (eq := by simp)
    have (b : Z ‚ü∂ B) := IsPullback.of_isLimit <| (pb b).isLimitAux
      (lift := fun s ‚Ü¶ s.snd ‚â´ snd _ _)
      (fac_left := fun s ‚Ü¶ by simp [pb, <-whiskerLeft_snd, <-PullbackCone.condition_assoc])
      (fac_right := fun s ‚Ü¶ by
        simp [pb]
        apply hom_ext
        ¬∑ simp; rw [<-whiskerLeft_fst, <-whiskerLeft_snd]
          repeat rw [<-PullbackCone.condition_assoc]
          simp
        ¬∑ simp)
      (uniq := fun s m h ‚Ü¶ by
        rw [(by aesop: m = m ‚â´ lift b (ùüô Z) ‚â´ snd B Z)]
        erw [<-Category.assoc, h .right])
    simp (contextual := true) at this
    replace (b: Z ‚ü∂ B) := IsPullback.paste_horiz (this b) (isPullback_œá (diag B)).flip 
    have ‚ü®p, q‚ü© := CartesianMonoidalCategory.hom_ext_iff.mp 
      <| IsPullback.isoIsPullback_hom_snd (Œ©‚ÇÄ Œµ) (Y := B ‚äó Z)
        (snd := lift b‚ÇÅ (ùüô Z)) (snd' := lift b‚ÇÇ (ùüô Z)) (h.subst <| this b‚ÇÅ) (this b‚ÇÇ)
    simp at q
    simpa [q] using p.symm

/-- The singelton predicate is the characteristic function of the singleton arrow.
This is also denoted as `œÉ_c`. -/
@[simp]
def singleton_predicate (B : Œµ) : P' B ‚ü∂ Œ© Œµ :=
  HasClassifier.œá (singleton B)

/-- The "truth of `B`" arrow is the transpose of the arrow `truth ‚àò !_B`. -/
@[reducible]
def truth_of (B : Œµ) : Œ©‚ÇÄ Œµ ‚ü∂ P' B :=
  transpose (fst _ _ ‚â´ œá‚ÇÄ _ ‚â´ truth _)

@[instance]
def truth_of.Mono (B : Œµ) : Mono (truth_of B) :=
  (isTerminalŒ©‚ÇÄ Œµ).mono_from _

@[simp]
lemma singleton_comp_predicate_eq (B : Œµ) :
    singleton B ‚â´ singleton_predicate B = œá‚ÇÄ B ‚â´ truth Œµ := by
  simp [HasClassifier.comm]; rfl

/-- In a topos, every mono is an equalizer [MM92]. -/
def fork_of_mono (f : A ‚ü∂ B) [isMono : Mono f] :
    Limits.Fork (HasClassifier.œá f) (œá‚ÇÄ B ‚â´ truth Œµ) :=
  Limits.Fork.ofŒπ f (by simpa using HasClassifier.comm f)

omit [HasPullbacks Œµ] in
@[simp]
lemma fork_of_mono_Œπ (f : A ‚ü∂ B) [Mono f] :
    (fork_of_mono f).Œπ = f := by simp [fork_of_mono]

/-- The arrow given by `fork_of_mono` is, in fact, an equalizer. ([MM92], Proposition IV.1.2) -/
def fork_of_mono.IsLimit (f : A ‚ü∂ B) [Mono f] : IsLimit (fork_of_mono f) := {
  lift (s: Fork _ _) :=
    (isPullback_œá f).lift
      (h := s.œÄ.app .zero)
      (k := œá‚ÇÄ _)
      (w := by simp[s.condition])
  fac (s: Fork _ _) j := by cases j <;> simp
  uniq (s: Fork _ _) m h := by
    simp
    have := (isPullback_œá f).isLimit.existsUnique { s with
      œÄ := {
        app
          | .left => m ‚â´ f
          | .right => HasClassifier.œá‚ÇÄ _
          | .one => œá‚ÇÄ _ ‚â´ truth _
        naturality j‚ÇÅ j‚ÇÇ f' := by
          rcases j‚ÇÅ with _ | _ | _
            <;> rcases j‚ÇÇ with _ | _ | _
          all_goals try simp [(by subsingleton: f' = ùüô _)]
          case some.left.none =>
            specialize h .one; simp at h
            simp [(by subsingleton: f' = WalkingCospan.Hom.inl), h, s.condition]
          case some.right.none =>
            simp [(by subsingleton: f' = WalkingCospan.Hom.inr)]
          all_goals nomatch f'
      }
    }
    apply this.unique <;> clear this
    all_goals
      intro j
      rcases j with _ | _ | _
      ¬∑ specialize h .one; simp_all [s.condition]
      ¬∑ specialize h .zero; simp_all
      ¬∑ apply (HasClassifier.isTerminalŒ©‚ÇÄ Œµ).hom_ext
}

omit [HasPullbacks Œµ] [Topos Œµ] in
/-- In a topos, arrows which are both mono and epi are isomorphisms. ([MM92], Proposition IV.1.2) -/
lemma iso_of_mono_of_epi {A B : Œµ} (f : A ‚ü∂ B) [is_mono : Mono f] [is_epi : Epi f] : IsIso f := by
  rw [<-fork_of_mono_Œπ f]
  have : Epi (fork_of_mono f).Œπ := by assumption
  apply Limits.isIso_limit_cone_parallelPair_of_epi (fork_of_mono.IsLimit f)

variable (B C : Œµ)

/-
  # The construction of exponentials
  We follow the construction in [MM92].
  The exponential is defined as the pullback of the bottom rectangle in the following diagram,
  where `v` is the `P`-transpose of `‚àà (C √ó B)` and `u` is the `P`-transpose of `v ‚â´ œÉ_C`.
  ([MM92], IV.2.(1))
```
                  ‚àà_(C √ó B)
  C √ó B √ó P(C √ó B) -------> Œ©
    
                 v        œÉ_C
  B √ó P(C √ó B) -----> PC ----> Œ©

  P(C √ó B) -------u---------> PB 
      ^                       ^ 
      |                       |
      | m                     | truth_of
      |                       |
     C^B -------------------> ‚ä§.
```
-/

@[reducible]
def v : B ‚äó P' (C ‚äó B) ‚ü∂ P' C :=
  transpose ((Œ±_ _ _ _).inv ‚â´ mem (C ‚äó B))

@[reducible]
def u : P' (C ‚äó B) ‚ü∂ P' B :=
  Topos.transpose (v B C ‚â´ singleton_predicate C)

@[simp]
def exp : Œµ := pullback (truth_of B) (u B C)

/-- The exponentiation of B on some object C, C^B. -/
def m : exp B C ‚ü∂ P' (C ‚äó B) := pullback.snd (truth_of B) (u B C)

/- Since `m` is the pullback of a mono, it is also mono. -/
lemma m_mono : Mono (m B C) := pullback.snd_of_mono

/-!
We construct the following diagram, where the desired evaluation map is the
lift of the pullback on the far right.
```
      --------------------evaluation map, e-------------------|
      |     1 √ó m                    v        singleton_pred  v
  B √ó C^B ---------> B √ó P(C √ó B) -------> PC <-------------- C
      |                   |                |                  |
      | 1√ó!               | 1 √ó u          | œÉ_C              |
      |                   |                |                  |
      v                   v                v                  v
    B √ó ‚ä§ --------------> ‚ä§ -------------> Œ© <--------------- ‚ä§
      |   1 √ó truth_of B          ‚àà_B              true       ^
      --------------------------------------------------------|
```
-/

@[reducible]
protected def e_defining_pullback_cone_middle : PullbackCone (mem B) (singleton_predicate C) := .mk
  (W := B ‚äó P' (C ‚äó B))
  (fst := B ‚óÅ (u B C))
  (snd := v B C)
  (eq := by erw [whiskerLeft_transpose_comp_mem])

@[reducible]
protected def e_defining_pullback_cone_left :
    PullbackCone (B ‚óÅ (truth_of B)) (B ‚óÅ (u B C)) := .mk
  (W := B ‚äó exp B C)
  (fst := B ‚óÅ (HasClassifier.œá‚ÇÄ _))
  (snd := B ‚óÅ (pullback.snd (truth_of B) (u B C)))
  (eq := by
    apply Limits.prod.hom_ext
    all_goals
      repeat rw [<-whiskerLeft_comp]
      rw [<-pullback.condition]
      simp; apply congrArg (¬∑ ‚â´ _)
      apply hom_ext
      ¬∑ simp
      ¬∑ apply (isTerminalŒ©‚ÇÄ _).hom_ext)

@[reducible]
protected def e_defining_pullback_cone : PullbackCone (œá (singleton C)) (truth Œµ) := .mk
  (W := B ‚äó exp B C)
  (fst := _ ‚óÅ (pullback.snd _ _) ‚â´ v B C)
  (snd := HasClassifier.œá‚ÇÄ _) <| by
    erw [Category.assoc, <-(Topos.e_defining_pullback_cone_middle B C).condition]
    erw [<-Category.assoc, <-(Topos.e_defining_pullback_cone_left B C).condition]
    simp

/-- The evaluation map `B √ó B^C ‚ü∂ C`. -/
def e : B ‚äó exp B C ‚ü∂ C :=
  (isPullback_œá (singleton C)).lift
    (Topos.e_defining_pullback_cone B C).fst
    (Topos.e_defining_pullback_cone B C).snd
    (Topos.e_defining_pullback_cone B C).condition

protected lemma e_comp_singleton_eq_defining_fst :
    e B C ‚â´ singleton C = (Topos.e_defining_pullback_cone B C).fst := by simp [e]

end
variable {B C : Œµ} (f : B ‚äó A ‚ü∂ C)

/-- The exponential transposition map. -/
def exp_transposition : A ‚ü∂ P' (C ‚äó B) := transpose ((Œ±_ _ _ _).hom ‚â´ (C ‚óÅ f) ‚â´ Œ¥ C)

lemma exp_trans_comp_eq_œá‚ÇÄ_comp_truth_of :
    œá‚ÇÄ A ‚â´ truth_of B = exp_transposition f ‚â´ u B C := by
  let a := (Œ±_ _ _ _).hom ‚â´ C ‚óÅ f ‚â´ Œ¥ C
  have : a = transpose.symm (transpose a) := by simp
  dsimp [transpose] at this; subst a
  apply congrArg ((Œ±_ _ _ _).inv ‚â´ ¬∑) at this
  rw [Iso.inv_hom_id_assoc] at this
  apply congrArg transpose at this

  erw [(?_: transpose (C ‚óÅ f ‚â´ Œ¥ C) = f ‚â´ singleton C)] at this
  swap; ¬∑ apply (exists_transpose _).choose_eq_iff.mpr; simp

  erw [(?_: transpose _ = B ‚óÅ (exp_transposition f) ‚â´ v B C)] at this
  ¬∑ apply congrArg (¬∑ ‚â´ singleton_predicate C) at this
    simp only [Category.assoc, singleton_comp_predicate_eq] at this
    conv_lhs at this => calc _
      _ = œá‚ÇÄ _ ‚â´ truth Œµ := by simp
    apply congrArg transpose at this
    convert this
    ¬∑ apply transpose.symm_apply_eq.mp
      simp [transpose]
    ¬∑ simp [u]
  ¬∑ erw [whiskerLeft_transpose_comp_mem, Iso.inv_hom_id_assoc]
    apply (ExistsUnique.choose_eq_iff _).mpr
    conv_lhs =>
      conv => calc _
        _ = C ‚óÅ (B ‚óÅ (exp_transposition f)) ‚â´ (C ‚óÅ (v B C) ‚â´ mem C) := by simp
      erw [whiskerLeft_transpose_comp_mem]
      rw [associator_inv_naturality_right_assoc]
      erw [whiskerLeft_transpose_comp_mem]; simp

protected abbrev exp_adjunction : A ‚ü∂ exp B C :=
  pullback.lift (œá‚ÇÄ _) (exp_transposition f) (exp_trans_comp_eq_œá‚ÇÄ_comp_truth_of f)

protected theorem exp_adjunction_natural : B ‚óÅ (Topos.exp_adjunction f) ‚â´ (e B C) = f := by
  apply (singleton.Mono C).right_cancellation
  erw [Category.assoc, Topos.e_comp_singleton_eq_defining_fst]

  apply (exists_transpose <| _ ‚óÅ f ‚â´ Œ¥ C).unique
  swap; ¬∑ simp

  simp [Topos.exp_adjunction, exp_transposition]
  repeat rw [associator_inv_naturality_right_assoc]
  rw [<-whiskerLeft_comp_assoc, pullback.lift_snd, whiskerLeft_transpose_comp_mem]
  simp

protected theorem exp_adjunction_unique (g : A ‚ü∂ exp B C) (h : f = _ ‚óÅ g ‚â´ (e B C)) :
    Topos.exp_adjunction f = g := by
  apply congrArg (¬∑ ‚â´ singleton C) at h
  simp [e] at h
  apply congrArg transpose.symm at h
  simp[transpose] at h

  apply pullback.hom_ext
  ¬∑ apply (isTerminalŒ©‚ÇÄ Œµ).hom_ext
  erw [pullback.lift_snd]
  apply (ExistsUnique.choose_eq_iff _).mpr
  simp [h]

/-- The exponential functor. -/
def exponential (B : Œµ) : Œµ ‚•§ Œµ where
  obj C := exp B C
  map {A C} f := Topos.exp_adjunction (e B A ‚â´ f)
  map_id C := by
    apply pullback.hom_ext
    ¬∑ apply (isTerminalŒ©‚ÇÄ Œµ).hom_ext
    simp [Topos.exp_adjunction, exp_transposition]
    apply (ExistsUnique.choose_eq_iff _).mpr
    erw [(by simp [singleton]: Œ¥ C = C ‚óÅ (singleton C) ‚â´ mem C)]
    rw [<-whiskerLeft_comp_assoc, Topos.e_comp_singleton_eq_defining_fst]
    simp
  map_comp {A C D} f‚ÇÅ f‚ÇÇ := by
    apply pullback.hom_ext
    ¬∑ apply (isTerminalŒ©‚ÇÄ Œµ).hom_ext
    simp [Topos.exp_adjunction, exp_transposition]
    apply (ExistsUnique.choose_eq_iff _).mpr
    rw [whiskerLeft_comp]
    repeat rw [Category.assoc]
    rw [whiskerLeft_transpose_comp_mem]

    have := Topos.exp_adjunction_natural (e B A ‚â´ f‚ÇÅ)

    rw [tensor_whiskerLeft]
    conv_lhs =>
      rw [Category.assoc]
      rhs; rw [Category.assoc, Iso.inv_hom_id_assoc]
      rw [<-Category.assoc]
      conv in _ ‚óÅ _ ‚â´ _ ‚â´ _ => rw [<-whiskerLeft_comp_assoc C]
      erw [<-whiskerLeft_comp, this]
    simp

/-- The hom-set equivalence between `B ‚äó A ‚ü∂ C` and `A ‚ü∂ exp B C`. -/
@[simp]
def adjunction_hom_equiv (A B C : Œµ) : (B ‚äó A ‚ü∂ C) ‚âÉ (A ‚ü∂ exp B C) where
  toFun f := Topos.exp_adjunction f
  invFun g := _ ‚óÅ g ‚â´ e B C
  left_inv f := Topos.exp_adjunction_natural f
  right_inv g := Topos.exp_adjunction_unique (B ‚óÅ g ‚â´ e B C) g (by simp)

/-- The adjunction of the left monoidal tensor with exponentials. -/
def exponential_right_adjunction (B : Œµ) : tensorLeft B ‚ä£ exponential B := .mkOfHomEquiv {
  homEquiv A C := adjunction_hom_equiv A B C
  homEquiv_naturality_right {A C D} f g := by
    simp
    change Topos.exp_adjunction (f ‚â´ g) = Topos.exp_adjunction f ‚â´ (exponential B).map g
    dsimp [Topos.exp_adjunction, exponential]

    apply Limits.pullback.hom_ext
    ¬∑ apply (isTerminalŒ©‚ÇÄ _).hom_ext
    simp
    apply (ExistsUnique.choose_eq_iff _).mpr
    simp; rw [<-whiskerLeft_comp_assoc, <-Category.assoc, <-whiskerLeft_comp]
    rw [associator_inv_naturality_right]
    repeat rw [Category.assoc]
    rw [whiskerLeft_comp]
    repeat rw [Category.assoc]
    erw [whiskerLeft_transpose_comp_mem]
    simp
    rw [<-Category.assoc]; apply congrArg (¬∑ ‚â´ _)
    rw [<-whiskerLeft_comp]; apply congrArg (_ ‚óÅ ¬∑)
    change (adjunction_hom_equiv A B C).symm ((adjunction_hom_equiv A B C) f) = f
    rw [Equiv.symm_apply_apply]
}

/-- All topos are cartesian closed. -/
instance : CartesianClosed Œµ where
  closed B := {
    rightAdj := exponential B
    adj := exponential_right_adjunction B
  }

end Topos
end
end CategoryTheory
